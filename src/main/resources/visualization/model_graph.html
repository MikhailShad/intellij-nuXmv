<!DOCTYPE html>
<html lang="en" style="background: transparent !important;">
<head>
    <meta charset="UTF-8">
    <title>NuXmv Model Visualization</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: transparent !important;
            background: none !important;
        }

        /* Main layout using flexbox for better structure */
        body {
            display: flex;
            flex-direction: column;
            background-color: transparent !important;
            background-image: none !important;
            box-shadow: none !important;
            border: none !important;
        }

        /* Graph container with proper padding to avoid overlapping panels */
        #cy-container {
            position: relative;
            flex: 1;
            width: 100%;
            height: calc(100% - 60px); /* Account for control panel height */
            padding-top: 60px; /* Space for top control panel */
            box-sizing: border-box;
            background-color: transparent !important;
        }

        /* The actual Cytoscape graph container */
        #cy {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 60px; /* Pushed down for control panel */
            left: 0;
            background-color: transparent !important;
        }

        /* Loop transition styling */
        .loop-transition {
            stroke-dasharray: 5, 5;
            line-color: #ff9500 !important;
            target-arrow-color: #ff9500 !important;
            width: 3px !important;
        }

        .empty-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 14px;
            text-align: center;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        /* Legend panel */
        .legend-panel {
            position: fixed;
            left: 10px;
            top: 60px; /* Below the control panel */
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 10px;
            font-size: 12px;
            z-index: 20;
            max-width: 180px;
            border: 1px solid #ddd;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 13px;
            color: #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .legend-close {
            cursor: pointer;
            font-size: 16px;
            color: #999;
        }

        .legend-close:hover {
            color: #666;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Fixed control panel at the top */
        .control-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 5px 10px;
            border-bottom: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .trace-navigation {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-button {
            background-color: #4f81bd;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .nav-button:hover {
            background-color: #2a5784;
        }

        .nav-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Compact state details panel in the bottom right corner */
        .state-details {
            position: fixed;
            right: 10px;
            bottom: 10px;
            max-width: 350px;
            max-height: 250px;
            background-color: rgba(255, 255, 255, 0.97);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.15);
            z-index: 20;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(200, 200, 200, 0.5);
        }

        .details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background-color: #4f81bd;
            color: white;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            flex-shrink: 0;
        }

        .details-header h3 {
            margin: 0;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .close-button {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0 0 0 10px;
            line-height: 1;
        }

        /* State variables table */
        #state-variables {
            padding: 5px;
            overflow-y: auto;
            max-height: 200px;
            font-size: 12px;
            width: 100%;
        }

        .variables-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        .variables-table th,
        .variables-table td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .variables-table th {
            background-color: #f6f6f6;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .variables-table td {
            word-break: break-word;
        }

        .variable-name {
            font-weight: 600;
            color: #2a5784;
            width: 40%;
        }

        /* Added styles for better panel integration */
        #controls {
            backdrop-filter: blur(5px);
        }

        #state-details {
            backdrop-filter: blur(5px);
            opacity: 0.97;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.23.0/cytoscape.min.js"></script>
</head>
<body>
<div id="controls" class="control-panel hidden">
    <div class="trace-selector">
        <label for="trace-select">Trace: </label>
        <select id="trace-select"></select>
    </div>
    <div id="success-message" class="hidden" style="color: #2e8b57; font-weight: bold;">
        Model verification successful! No counterexamples found.
    </div>
    <div class="trace-navigation">
        <button id="prev-state" class="nav-button" disabled>◀ Previous</button>
        <span id="state-info">State: -</span>
        <button id="next-state" class="nav-button" disabled>Next ▶</button>
        <button id="play-button" class="nav-button" disabled>▶ Play</button>
    </div>
</div>

<div id="cy-container">
    <div id="empty-message" class="empty-message">
        <h3>NuXmv Model Visualization</h3>
        <p>Waiting for model data...</p>
    </div>
    <div id="legend" class="legend-panel hidden">
        <div class="legend-title">
            <span>Variables</span>
            <span class="legend-close" title="Close legend">×</span>
        </div>
        <div id="legend-items">
            <!-- Legend items will be generated here -->
        </div>
    </div>
    <div id="cy"></div>
</div>

<div id="state-details" class="state-details hidden">
    <div class="details-header">
        <h3 id="state-details-title">State Details</h3>
        <button id="close-details" class="close-button">×</button>
    </div>
    <div id="state-variables"></div>
</div>
<script>
    let cy = null;
    let modelData = null;
    let activeTrace = -1;
    let currentStateKey = null;
    let currentKeyIndex = -1;
    let isMovingForward = true;
    let playInterval = null;
    let isPlaying = false;

    function initCytoscape() {
        if (cy !== null) {
            return;
        }

        const cyContainer = document.getElementById('cy');
        const containerWrapper = document.getElementById('cy-container');

        if (!cyContainer || !containerWrapper) {
            console.error("Cytoscape container elements not found");
            return;
        }

        containerWrapper.style.height = `${window.innerHeight}px`;

        cy = cytoscape({
            container: cyContainer,
            userZoomingEnabled: true,
            userPanningEnabled: true,
            boxSelectionEnabled: false,
            autounselectify: false,
            wheelSensitivity: 0.2,
            styleEnabled: true,
            hideEdgesOnViewport: false,
            hideLabelsOnViewport: false,
            textureOnViewport: false,
            motionBlur: true,
            motionBlurOpacity: 0.2,
            pixelRatio: 'auto',
            background: 'transparent',
            style: [
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'background-color': '#888888',
                        'color': 'white',
                        'font-size': '12px',
                        'width': 50,
                        'height': 50,
                        'text-wrap': 'wrap',
                        'text-max-width': '46px',
                        'text-overflow-wrap': 'anywhere',
                        'text-justification': 'center',
                        'shape': 'ellipse',
                        'border-width': 0
                    }
                },
                {
                    selector: 'node.value',
                    style: {
                        'background-color': 'data(color)',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '12px',
                        'color': 'white',
                        'width': 'label',
                        'height': 'label',
                        'padding': '10px',
                        'shape': 'ellipse',
                        'text-wrap': 'wrap',
                        'label': 'data(variableValue)'
                    }
                },
                {
                    selector: 'node.variable',
                    style: {
                        'opacity': 0,
                        'width': 0,
                        'height': 0
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 2,
                        'line-color': '#999',
                        'target-arrow-color': '#999',
                        'target-arrow-shape': 'triangle',
                        'arrow-scale': 1.2,
                        'curve-style': 'bezier',
                        'label': 'data(condition)',
                        'font-size': '10px',
                        'text-background-color': 'white',
                        'text-background-opacity': 0.8,
                        'text-background-padding': '2px',
                        'text-rotation': 'autorotate',
                        'text-wrap': 'wrap',
                        'text-max-width': '100px',
                        'edge-text-rotation': 'autorotate',
                        'min-zoomed-font-size': 6
                    }
                },
                {
                    selector: '.highlighted',
                    style: {
                        'border-width': 3,
                        'border-color': '#ff5500',
                        'border-style': 'solid',
                        'opacity': 1.0,
                        'z-index': 999
                    }
                },
                {
                    selector: '.transition',
                    style: {
                        'line-color': '#ff5500',
                        'target-arrow-color': '#ff5500',
                        'width': 3,
                        'arrow-scale': 1.5,
                        'z-index': 999
                    }
                },
                {
                    selector: '.trace-path',
                    style: {
                        'border-width': 2,
                        'border-color': '#daa520',
                        'border-style': 'dashed'
                    }
                },
                {
                    selector: '.trace-edge',
                    style: {
                        'line-color': '#daa520',
                        'target-arrow-color': '#daa520',
                        'width': 2,
                        'line-style': 'dashed',
                        'z-index': 900
                    }
                },
                {
                    selector: '.current-trace-path',
                    style: {
                        'border-width': 3,
                        'border-color': '#ff0000',
                        'border-style': 'solid'
                    }
                },
                {
                    selector: '.current-trace-edge',
                    style: {
                        'line-color': '#ff0000',
                        'target-arrow-color': '#ff0000',
                        'width': 3,
                        'line-style': 'solid',
                        'z-index': 950
                    }
                },
                {
                    selector: 'node.initial-state',
                    style: {
                        'border-width': 3,
                        'border-color': '#008800',
                        'border-style': 'double',
                        'z-index': 900
                    }
                }
            ],
            layout: {
                name: 'cose',
                animate: false,
                nodeDimensionsIncludeLabels: true,
                idealEdgeLength: 150,
                nodeOverlap: 10,
                padding: 50,
                nodeRepulsion: 1000000,
                edgeElasticity: 100,
                gravity: 80,
                numIter: 3000,
                initialTemp: 200,
                coolingFactor: 0.95,
                minTemp: 1.0,
                randomize: false
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function () {
        initCytoscape();
        setupUIEventHandlers();
        setupResizeHandler();

        window.addEventListener('beforeunload', function () {
            if (isPlaying && playInterval) {
                clearInterval(playInterval);
            }
        });
    });

    function setupResizeHandler() {
        let resizeTimeout;

        window.addEventListener('resize', function () {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function () {
                const containerWrapper = document.getElementById('cy-container');
                if (containerWrapper) {
                    containerWrapper.style.height = `${window.innerHeight - 60}px`;
                }

                if (cy) {
                    cy.resize();
                    cy.fit();
                    cy.center();
                }
            }, 250);
        });

        if (window.ResizeObserver) {
            const containerWrapper = document.getElementById('cy-container');
            if (containerWrapper) {
                const resizeObserver = new ResizeObserver(function () {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(function () {
                        if (cy) {
                            cy.resize();
                            cy.fit();
                            cy.center();
                        }
                    }, 250);
                });
                resizeObserver.observe(containerWrapper);
                console.log("ResizeObserver set up for container wrapper");
            }
        }
    }

    try {
        initCytoscape();
    } catch (e) {
        console.error("Error in immediate initialization:", e);
    }

    function updateVisualization(dataJson) {
        try {
            console.log("Received data:", dataJson.substring(0, 200) + "...");
            modelData = JSON.parse(dataJson);

            if (!modelData || typeof modelData !== 'object') {
                console.error("Invalid model data format");
                return;
            }

            console.log("Parsed model data:", modelData);

            document.getElementById('empty-message').classList.add('hidden');
            document.getElementById('controls').classList.remove('hidden');

            // Handle successful verification (no counterexamples) case
            const traceSelector = document.querySelector('.trace-selector');
            const traceNavigation = document.querySelector('.trace-navigation');
            const successMessage = document.getElementById('success-message');

            const traces = modelData.traces ? JSON.parse(modelData.traces) : [];
            const hasTraces = traces && traces.length > 0;

            // Show/hide UI elements based on trace existence
            if (hasTraces) {
                traceSelector.classList.remove('hidden');
                traceNavigation.classList.remove('hidden');
                successMessage.classList.add('hidden');
            } else {
                traceSelector.classList.add('hidden');
                traceNavigation.classList.add('hidden');
                successMessage.classList.remove('hidden');
            }

            generateLegend();

            if (!cy) {
                initCytoscape();
            }

            cy.startBatch();

            cy.elements().remove();

            const elements = [];

            if (modelData.nodes && modelData.nodes.length > 0) {
                for (const nodeData of modelData.nodes) {
                    const nodeClass = nodeData.isVariable ? 'variable' : (nodeData.isValue ? 'value' : '');

                    // Формируем список классов для узла
                    let nodeClasses = nodeClass;

                    // Добавляем класс для начального состояния
                    if (nodeData.isInitialState) {
                        nodeClasses += ' initial-state';
                    }

                    let customWidth, customHeight;

                    if (nodeData.label) {
                        const labelLength = nodeData.label.length;

                        if (nodeClass === 'variable') {
                            customWidth = Math.max(80, Math.min(150, 60 + labelLength * 5));
                            customHeight = Math.max(40, Math.min(60, 30 + Math.ceil(labelLength / 10) * 10));
                        } else if (nodeClass === 'value') {
                            customWidth = Math.max(50, Math.min(100, 40 + labelLength * 4));
                            customHeight = 40;
                        } else {
                            customWidth = Math.max(60, Math.min(120, 50 + labelLength * 4));
                            customHeight = Math.max(40, Math.min(60, 30 + Math.ceil(labelLength / 15) * 10));
                        }
                    }

                    if (nodeClass === 'value' && nodeData.variableName) {
                        nodeData.color = getColorForVariable(nodeData.variableName);
                    } else if (nodeClass === 'variable' && nodeData.label) {
                        nodeData.color = getColorForVariable(nodeData.label);
                        nodeData.hidden = true;
                    }

                    const nodeElement = {
                        group: 'nodes',
                        data: nodeData,
                        classes: nodeClasses
                    };

                    if (customWidth && customHeight) {
                        nodeElement.style = {
                            'width': customWidth,
                            'height': customHeight,
                            'text-max-width': customWidth - 4
                        };
                    }

                    elements.push(nodeElement);
                }
            }

            if (modelData.edges && modelData.edges.length > 0) {
                const edgeGroups = new Map();

                for (const edgeData of modelData.edges) {
                    if (!edgeData.id && edgeData.source && edgeData.target) {
                        edgeData.id = `${edgeData.source}_to_${edgeData.target}`;
                    }

                    const sourceId = edgeData.source;
                    const targetId = edgeData.target;
                    const key = `${sourceId}->${targetId}`;

                    if (!edgeGroups.has(key)) {
                        edgeGroups.set(key, []);
                    }
                    edgeGroups.get(key).push(edgeData);
                }

                let edgeCounter = 0;
                for (const [key, edgeList] of edgeGroups.entries()) {
                    for (let i = 0; i < edgeList.length; i++) {
                        const edgeData = edgeList[i];
                        const edgeId = edgeData.id || `edge-${++edgeCounter}`;

                        const edgeElement = {
                            group: 'edges',
                            data: {
                                ...edgeData,
                                id: edgeId
                            }
                        };

                        if (edgeList.length > 1) {
                            const curveDistance = 20 + (15 * i);
                            edgeElement.style = {
                                'curve-style': 'unbundled-bezier',
                                'control-point-distances': i % 2 === 0 ? curveDistance : -curveDistance,
                                'control-point-weights': 0.5
                            };
                        }

                        elements.push(edgeElement);
                    }
                }
            }

            cy.add(elements);

            const layout = cy.layout({
                name: 'cose',
                animate: false,
                nodeDimensionsIncludeLabels: true,
                idealEdgeLength: 150,
                nodeOverlap: 10,
                padding: 50,
                nodeRepulsion: 1000000,
                edgeElasticity: 100,
                gravity: 80,
                numIter: 3000,
                initialTemp: 200,
                coolingFactor: 0.95,
                minTemp: 1.0,
                randomize: false,
                fit: true
            });

            layout.run();

            cy.endBatch();

            if (hasTraces) {
                populateTraceSelector();
                const firstTrace = traces[0].traceNumber.toString();
                showTrace(firstTrace);
            }
        } catch (e) {
            console.error("Error in updateVisualization:", e);
        }
    }

    function getColorForVariable(variableName) {
        if (!window.variableColors) {
            window.variableColors = new Map();
        }

        if (window.variableColors.has(variableName)) {
            return window.variableColors.get(variableName);
        }

        const usePredefined = true;

        if (usePredefined) {
            const colors = [
                '#4f81bd',
                '#c0504d',
                '#9bbb59',
                '#8064a2',
                '#4bacc6',
                '#6b83ab',
                '#b66d6b',
                '#749a53',
                '#6f5a7e',
                '#458b9a',
                '#4b5fbd',
                '#c04d8d',
                '#59bb80',
                '#a264a2',
                '#4bacc6',
            ];

            let hash = 0;
            for (let i = 0; i < variableName.length; i++) {
                hash = ((hash << 5) - hash) + variableName.charCodeAt(i);
                hash = hash & hash;
            }

            const index = Math.abs(hash) % colors.length;
            const color = colors[index];

            window.variableColors.set(variableName, color);
            return color;
        } else {

            let hash = 0;
            for (let i = 0; i < variableName.length; i++) {
                hash = ((hash << 5) - hash) + variableName.charCodeAt(i);
                hash = hash & hash;
            }

            const hue = Math.abs(hash) % 360;

            const saturation = 65;
            const lightness = 40;

            const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

            window.variableColors.set(variableName, color);
            return color;
        }
    }

    function populateTraceSelector() {
        const traceSelect = document.getElementById('trace-select');
        traceSelect.innerHTML = '';

        const traces = JSON.parse(modelData.traces || '[]');
        if (!traces || traces.length === 0) {
            return;
        }

        traces.forEach((trace, index) => {
            const option = document.createElement('option');
            option.value = trace.traceNumber.toString();

            let displayText = `Trace ${trace.traceNumber}`;
            if (trace.description) {
                displayText += `: ${trace.description}`;
            } else if (trace.type) {
                displayText += `: ${trace.type}`;
            }
            if (trace.specification) {
                const specText = trace.specification.length > 30 ?
                        trace.specification.substring(0, 30) + '...' : trace.specification;
                displayText += ` - ${specText}`;
            }

            option.text = displayText;
            traceSelect.appendChild(option);
        });

        traceSelect.onchange = function () {
            showTrace(this.value);
        };
    }

    function showTrace(traceId) {
        if (!modelData || !modelData.traces) {
            return;
        }

        if (isPlaying) {
            togglePlayback();
        }

        cy.elements().removeClass('trace-path').removeClass('trace-edge')
                .removeClass('highlighted').removeClass('transition')
                .removeClass('current-trace-path').removeClass('current-trace-edge');

        const traces = JSON.parse(modelData.traces || '[]');
        const trace = traces.find(t => t.traceNumber.toString() === traceId.toString());
        if (!trace || !trace.states || Object.keys(trace.states).length === 0) {
            console.error("Trace not found or has no states:", traceId);
            return;
        }

        activeTrace = traceId;

        const stateKeys = Object.keys(trace.states).sort((a, b) => {
            return parseFloat(a) - parseFloat(b);
        });

        const prevButton = document.getElementById('prev-state');
        const nextButton = document.getElementById('next-state');
        const playButton = document.getElementById('play-button');

        let loopStartKey = null;
        for (const key of stateKeys) {
            if (trace.states[key].isLoopStart) {
                loopStartKey = key;
                break;
            }
        }

        prevButton.onclick = function () {
            if (currentKeyIndex > 0) {
                isMovingForward = false;
                currentKeyIndex--;
                showState(stateKeys[currentKeyIndex]);
            }
        };

        nextButton.onclick = function () {
            isMovingForward = true;
            if (currentKeyIndex < stateKeys.length - 1) {
                currentKeyIndex++;
                showState(stateKeys[currentKeyIndex]);
            } else if (stateKeys.length > 0 && loopStartKey) {
                currentKeyIndex = stateKeys.indexOf(loopStartKey);
                showState(loopStartKey, true);
            }
        };

        if (stateKeys.length > 0) {
            playButton.disabled = false;
        } else {
            playButton.disabled = true;
        }

        currentKeyIndex = -1;
        currentStateKey = null;
        isMovingForward = true;

        if (stateKeys.length > 0) {
            showState(stateKeys[0]);
        }
    }

    function showState(stateKey, isLoopTransition = false) {
        if (!modelData || !modelData.traces) {
            return;
        }

        const traces = JSON.parse(modelData.traces || '[]');
        const trace = traces.find(t => t.traceNumber.toString() === activeTrace.toString());
        if (!trace || !trace.states || !trace.states[stateKey]) {
            console.error("State not found:", stateKey, "in trace:", activeTrace);
            return;
        }

        if (isLoopTransition) {
            isMovingForward = true;
        }

        currentStateKey = stateKey;
        const state = trace.states[stateKey];

        const stateKeys = Object.keys(trace.states).sort((a, b) => parseFloat(a) - parseFloat(b));
        currentKeyIndex = stateKeys.indexOf(stateKey);

        let prevState = null;
        let prevStateKey = null;
        if (isLoopTransition) {
            prevStateKey = stateKeys[stateKeys.length - 1];
            prevState = trace.states[prevStateKey];
        } else if (currentKeyIndex > 0) {
            prevStateKey = stateKeys[currentKeyIndex - 1];
            prevState = trace.states[prevStateKey];
        }

        let stateLabel = `State: ${stateKey}`;
        if (state.isLoopStart) {
            stateLabel += ' (loop start)';
        }

        document.getElementById('state-info').textContent = stateLabel;

        const prevButton = document.getElementById('prev-state');
        const nextButton = document.getElementById('next-state');
        const playButton = document.getElementById('play-button');

        if (!isPlaying) {
            prevButton.disabled = (currentKeyIndex === 0);

            let loopStartKey = null;
            for (const key of stateKeys) {
                if (trace.states[key].isLoopStart) {
                    loopStartKey = key;
                    break;
                }
            }

            const isLastState = (currentKeyIndex === stateKeys.length - 1);

            if (isLastState && loopStartKey) {
                nextButton.disabled = false;
                nextButton.textContent = "Loop ↻";
            } else if (isLastState && !loopStartKey) {
                nextButton.disabled = true;
                nextButton.textContent = "Next ▶";
            } else {
                nextButton.disabled = false;
                nextButton.textContent = "Next ▶";
            }
        }

        highlightState(state, prevState, stateKey, prevStateKey, isMovingForward);
        updateStateDetails(state, stateKey);
    }

    function highlightState(state, prevState, stateKey, prevStateKey, isMovingForward) {
        if (!state) return;

        if (!isMovingForward) {
            cy.nodes('.trace-path').removeClass('trace-path');
            cy.edges('.trace-edge').removeClass('trace-edge');
        }

        cy.nodes('.current-trace-path').removeClass('current-trace-path').addClass('trace-path');
        cy.edges('.current-trace-edge').removeClass('current-trace-edge').addClass('trace-edge');
        cy.elements().removeClass('highlighted').removeClass('transition');

        for (const [varName, value] of Object.entries(state.variables)) {
            const nodeId = `${varName}=${value}`;
            const node = cy.getElementById(nodeId);
            if (node.length > 0) {
                node.addClass('highlighted');
                node.addClass('current-trace-path');
                node.removeClass('trace-path');
            }
        }

        if (prevState) {
            for (const [varName, currentValue] of Object.entries(state.variables)) {
                const prevValue = prevState.variables[varName];

                if (prevValue === currentValue) continue;

                const edgeId = `${varName}=${prevValue}_to_${varName}=${currentValue}`;
                const edge = cy.getElementById(edgeId);

                if (edge.length > 0) {
                    edge.addClass('transition');
                    edge.addClass('current-trace-edge');
                    edge.removeClass('trace-edge');
                }
            }
        }

        cy.nodes('.highlighted, .current-trace-path').forEach(node => {
            node.style('z-index', 999);
        });

        cy.edges('.transition, .current-trace-edge').forEach(edge => {
            edge.style('z-index', 999);
        });
    }


    function generateLegend() {
        if (!modelData || !modelData.nodes) return;

        const legendItems = document.getElementById('legend-items');
        legendItems.innerHTML = '';

        const variableColors = new Map();

        modelData.nodes.forEach(node => {
            if (node.isVariable && node.label) {
                const varName = node.label;
                const color = getColorForVariable(varName);
                variableColors.set(varName, color);
            } else if (node.isValue && node.variableName) {
                const varName = node.variableName;
                const color = getColorForVariable(varName);
                variableColors.set(varName, color);
            }
        });

        const sortedVariables = Array.from(variableColors.keys()).sort();

        sortedVariables.forEach(varName => {
            const color = variableColors.get(varName);
            const item = document.createElement('div');
            item.className = 'legend-item';

            const colorSquare = document.createElement('div');
            colorSquare.className = 'legend-color';
            colorSquare.style.backgroundColor = color;

            const label = document.createElement('div');
            label.textContent = varName;

            item.appendChild(colorSquare);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        if (sortedVariables.length > 0) {
            document.getElementById('legend').classList.remove('hidden');
        }
    }

    function updateStateDetails(state, stateKey) {
        const detailsPanel = document.getElementById('state-details');
        const variablesContainer = document.getElementById('state-variables');
        const detailsTitle = document.getElementById('state-details-title');

        detailsPanel.classList.remove('hidden');

        let titleText = `State ${stateKey}`;
        if (state.isLoopStart) {
            titleText += ' (loop start)';
        }
        detailsTitle.textContent = titleText;

        variablesContainer.innerHTML = '';
        if (state.variables) {
            const table = document.createElement('table');
            table.className = 'variables-table';

            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th class="variable-name">Variable</th>
                    <th>Value</th>
                </tr>
            `;
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            const sortedVars = Object.entries(state.variables).sort((a, b) => a[0].localeCompare(b[0]));
            let prevState = null;
            const traces = JSON.parse(modelData.traces || '[]');
            const trace = traces.find(t => t.traceNumber.toString() === activeTrace.toString());

            if (trace) {
                const stateKeys = Object.keys(trace.states).sort((a, b) => parseFloat(a) - parseFloat(b));
                const currentIndex = stateKeys.indexOf(stateKey);

                if (currentIndex > 0) {
                    const prevStateKey = stateKeys[currentIndex - 1];
                    prevState = trace.states[prevStateKey];
                }
            }

            sortedVars.forEach(([varName, value]) => {
                const row = document.createElement('tr');

                let valueClass = '';
                if (prevState && prevState.variables) {
                    const prevValue = prevState.variables[varName];
                    if (prevValue !== undefined && prevValue !== value) {
                        valueClass = 'style="background-color: rgba(255, 220, 100, 0.3); font-weight: bold;"';
                    }
                }

                row.innerHTML = `
                    <td class="variable-name">${varName}</td>
                    <td ${valueClass}>${value}</td>
                `;
                tbody.appendChild(row);
            });

            table.appendChild(tbody);
            variablesContainer.appendChild(table);
        }
    }

    function setupUIEventHandlers() {
        const closeDetailsButton = document.getElementById('close-details');
        if (closeDetailsButton) {
            closeDetailsButton.addEventListener('click', function () {
                const stateDetails = document.getElementById('state-details');
                if (stateDetails) {
                    stateDetails.classList.add('hidden');
                }
            });
        }

        const closeLegendButton = document.querySelector('.legend-close');
        if (closeLegendButton) {
            closeLegendButton.addEventListener('click', function () {
                const legend = document.getElementById('legend');
                if (legend) {
                    legend.classList.add('hidden');
                }
            });
        }

        const playButton = document.getElementById('play-button');
        if (playButton) {
            playButton.addEventListener('click', function () {
                togglePlayback();
            });
        }

        const controlPanel = document.getElementById('controls');
        if (controlPanel) {
            const legendToggle = document.createElement('button');
            legendToggle.className = 'nav-button';
            legendToggle.textContent = 'Show Legend';
            legendToggle.style.marginLeft = '10px';
            legendToggle.addEventListener('click', function () {
                const legend = document.getElementById('legend');
                if (legend.classList.contains('hidden')) {
                    legend.classList.remove('hidden');
                    legendToggle.textContent = 'Hide Legend';
                } else {
                    legend.classList.add('hidden');
                    legendToggle.textContent = 'Show Legend';
                }
            });

            const navSection = document.querySelector('.trace-navigation');
            if (navSection) {
                navSection.appendChild(legendToggle);
            }
        }
    }

    function togglePlayback() {
        const playButton = document.getElementById('play-button');
        const nextButton = document.getElementById('next-state');
        const prevButton = document.getElementById('prev-state');

        if (isPlaying) {
            clearInterval(playInterval);
            playInterval = null;
            isPlaying = false;
            playButton.textContent = '▶ Play';
            nextButton.disabled = (currentKeyIndex === Object.keys(getTraceStates()).length - 1);
            prevButton.disabled = (currentKeyIndex === 0);
        } else {
            isPlaying = true;
            playButton.textContent = '⏸ Pause';
            nextButton.disabled = true;
            prevButton.disabled = true;

            playInterval = setInterval(function () {
                const stateKeys = Object.keys(getTraceStates()).sort((a, b) => parseFloat(a) - parseFloat(b));

                if (currentKeyIndex < stateKeys.length - 1) {
                    isMovingForward = true;
                    currentKeyIndex++;
                    showState(stateKeys[currentKeyIndex]);
                } else {
                    let loopStartKey = null;
                    const traces = JSON.parse(modelData.traces || '[]');
                    const trace = traces.find(t => t.traceNumber.toString() === activeTrace.toString());

                    if (trace) {
                        for (const key of stateKeys) {
                            if (trace.states[key].isLoopStart) {
                                loopStartKey = key;
                                break;
                            }
                        }
                    }

                    if (loopStartKey) {
                        currentKeyIndex = stateKeys.indexOf(loopStartKey);
                        showState(loopStartKey, true);
                    } else {
                        togglePlayback();
                    }
                }
            }, 1000);
        }
    }

    function getTraceStates() {
        if (!modelData || !modelData.traces) {
            return {};
        }

        const traces = JSON.parse(modelData.traces || '[]');
        const trace = traces.find(t => t.traceNumber.toString() === activeTrace.toString());

        if (!trace || !trace.states) {
            return {};
        }

        return trace.states;
    }

    function handleCommand(command, data) {
        switch (command) {
            case 'refresh':
                if (cy) {
                    updateLayoutForPanels();
                    cy.fit();
                    cy.center();
                }
                break;

            case 'fit':
                if (cy) {
                    updateLayoutForPanels();
                    cy.fit();
                    cy.center();
                }
                break;

            case 'resize':
                const containerWrapper = document.getElementById('cy-container');
                if (containerWrapper) {
                    containerWrapper.style.height = `${window.innerHeight - 60}px`;
                }

                setTimeout(() => {
                    if (cy) {
                        updateLayoutForPanels();
                        cy.resize();
                        cy.fit();
                        cy.center();
                    }
                }, 100);
                break;
        }
    }

    function updateLayoutForPanels() {
        const controlPanel = document.getElementById('controls');

        if (!controlPanel || !cy) return;

        const topPadding = 60;

        const cyContainer = document.getElementById('cy-container');
        if (cyContainer) {
            cyContainer.style.paddingRight = '0';
            cyContainer.style.paddingTop = `${topPadding}px`;

            cyContainer.style.width = '100%';
        }
    }

    // Export functions for Java to call
    window.updateVisualization = updateVisualization;
    window.handleCommand = handleCommand;
</script>
</body>
</html>
