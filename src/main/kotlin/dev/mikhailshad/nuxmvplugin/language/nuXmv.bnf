{
  parserClass="dev.mikhailshad.nuxmvplugin.language.parser.NuXmvParser"
  parserUtilClass="dev.mikhailshad.nuxmvplugin.language.parser.NuXmvParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="NuXmv"
  psiImplClassSuffix="Impl"
  psiPackage="dev.mikhailshad.nuxmvplugin.language.psi"
  psiImplPackage="dev.mikhailshad.nuxmvplugin.language.psi.impl"

  elementTypeHolderClass="dev.mikhailshad.nuxmvplugin.language.psi.NuXmvTypes"
  elementTypeClass="dev.mikhailshad.nuxmvplugin.language.psi.NuXmvElementType"
  tokenTypeClass="dev.mikhailshad.nuxmvplugin.language.psi.NuXmvTokenType"

  tokens=[
    WHITESPACE      ='regexp:\s+'
    BLOCK_COMMENT   = 'regexp:/--(.|\r|\n)*--/'
    LINE_COMMENT    = 'regexp:--[^\r\n]*'

    LTLSPEC         = 'LTLSPEC'
    CTLSPEC         = 'CTLSPEC'
    INVARSPEC       = 'INVARSPEC'
    SPEC            = 'SPEC'

    MODULE          = 'MODULE'
    SELF            = 'self'
    TRUE            = 'TRUE'
    FALSE           = 'FALSE'

    NOT             = '!'
    AND             = '&'
    OR              = '|'
    XOR             = 'xor'
    NOT_XOR         = 'xnor'
    IMPLICATION     = '->'
    EQUIVALENCE     = '<->'
    EQUALITY        = '='
    NOT_EQUALITY    = '!='
    LESS            = '<'
    GREATER         = '>'
    LESS_EQ         = '<='
    GREATER_EQ      = '>='

    ASSIGN          = ':='

    MINUS           = '-'
    PLUS            = '+'
    MULT            = '*'
    DIV             = '/'
    MOD             = 'mod'

    SHIFT_RIGHT     = '>>'
    SHIFT_LEFT      = '<<'

    LPAREN          = '('
    RPAREN          = ')'
    LBRACE          = '{'
    RBRACE          = '}'
    LBRACKET        = '['
    RBRACKET        = ']'
    DOT             = '.'
    COMMA           = ','
    SEMICOLON       = ';'
    COLON           = ':'
    RANGE           = '..'
    CONCAT          = '::'

    TO_WORD1        = 'word1'
    TO_BOOL         = 'bool'
    TO_INT          = 'toint'
    TO_SIGNED       = 'signed'
    TO_UNSIGNED     = 'unsigned'
    EXTEND          = 'extend'
    RESIZE          = 'resize'
    UNION           = 'union'
    IN              = 'in'
    QUESTION_MARK   = '?'
    COUNT           = 'count'
    FLOOR           = 'floor'
    NEXT            = 'next'
    CASE            = 'case'
    ESAC            = 'esac'

    // Type Specifier
    BOOLEAN_TYPE        = 'boolean'
    WORD_TYPE           = 'word'
    UNSIGNED_WORD_TYPE  = 'unsigned word'
    SIGNED_WORD_TYPE    = 'signed word'
    INTEGER_TYPE        = 'integer'
    REAL_TYPE           = 'real'
    CLOCK_TYPE          = 'clock'
    ARRAY_TYPE          = 'array'
    ARRAY_OF            = 'of'

    // State, Input, Frozen Variables
    VAR              = 'VAR'
    IVAR             = 'IVAR'
    FROZENVAR        = 'FROZENVAR'

    // Other
    FUN_KW           = 'FUN'
    DEFINE_KW        = 'DEFINE'
    CONSTANTS_KW     = 'CONSTANTS'
    ASSIGN_KW        = 'ASSIGN'
    INIT_FUN         = "init"
    INIT_KW          = "INIT"
    TRANS_KW         = "TRANS"
    INVAR_KW         = "INVAR"
    FAIRNESS_KW      = "FAIRNESS"
    JUSTICE_KW       = "JUSTICE"
    COMPASSION_KW    = "COMPASSION"
    TIME_DOMAIN_KW   = "@TIME DOMAIN"
    PRED_KW          = "PRED"
    MIRROR_KW        = "MIRROR"
    ISA_KW           = "ISA"
    NAME_KW          = "NAME"
    COMPUTE_KW       = "COMPUTE"
    MIN_KW           = "MIN"
    MAX_KW           = "MAX"
    PARSYNTH_KW      = "PARSYNTH"
    VALID_KW         = "VALID"
    SAT_KW           = "SAT"
    MONOPOS_KW       = "MONOPOS"
    MONONEG_KW       = "MONONEG"

    IDENTIFIER = "regexp:[A-Za-z_][A-Za-z_0-9$\-#]*"
    POSITIVE_INTEGER_NUMBER = "regexp:[0-9]+"
    INTEGER_NUMBER = "regexp:-?[0-9]+"
    FLOAT_NUMBER = "regexp:[0-9]+\.[0-9]+"
    FRACTIONAL_NUMBER = "regexp:[fF]'[0-9]+/[0-9]+"
    EXPONENTIAL_NUMBER = "regexp:([0-9]+|[0-9]+/[0-9]+)[eE](-?[0-9]+)"
  ]

  extends(".*Expr")=Expr
}

/*
CODE FORMATTING
===============
- tokens are in ALL_CAPS
- grammar rules are in CamelCase
- meta rules and recoverWhile predicates should be in snake_case
 */

NuXmvFile ::= !<<eof>> NuXmvModule+ {pin=1}
NuXmvModule ::= ModuleDeclaration ModuleBody?
ModuleDeclaration ::= MODULE ModuleName (LPAREN ModuleParameters RPAREN)? {pin=1}
ModuleName ::= IDENTIFIER
ModuleParameters ::= IDENTIFIER (COMMA IDENTIFIER)*
ModuleBody ::= ModuleElement+
private ModuleElement ::= VarDeclaration
    | IvarDeclaration
    | FrozenVarDeclaration
    | FunctionDeclaration
    | DefineDeclaration
    | ConstantsDeclaration
    | AssignConstraint
    | TransConstraint
    | InitConstraint
    | InvarConstraint
    | FairnessConstraint
    | JusticeConstraint
    | CompassionConstraint
    | CtlSpecification
    | LtlSpecification
    | InvarSpecification
    | ComputeSpecification
    | ParameterSynthProblemDeclaration
    | IsaDeclaration
    | PredDeclaration
    | MirrorDeclaration
    {recoverWhile=module_element_recover}

private module_element_recover ::= !(
    SEMICOLON | RBRACKET | RPAREN
    | VAR | IVAR | FROZENVAR
    | DEFINE_KW | CONSTANTS_KW | ASSIGN_KW | TRANS_KW | INIT_KW | INVAR_KW | COMPASSION_KW | FAIRNESS_KW | JUSTICE_KW
    | LTLSPEC | CTLSPEC | SPEC | INVARSPEC
    | COMPUTE_KW | PARSYNTH_KW
    | ISA_KW | PRED_KW | MIRROR_KW
    | MODULE
    )

CtlSpecification ::= CtlSpecKeyWord CtlNamedSpecification? Expr SEMICOLON? {pin=1}
private CtlSpecKeyWord ::= CTLSPEC | SPEC
private CtlNamedSpecification ::=  NAME_KW SimpleIdentifier ASSIGN

LtlSpecification ::= LTLSPEC LtlNamedSpecification? Expr SEMICOLON? {pin=1}
private LtlNamedSpecification ::= NAME_KW SimpleIdentifier ASSIGN

InvarSpecification ::= INVARSPEC NamedInvarSpecification? Expr SEMICOLON? {pin=1}
private NamedInvarSpecification ::= NAME_KW SimpleIdentifier ASSIGN

VarDeclaration ::= VAR SingleVarDeclaration+ {pin=1}
SingleVarDeclaration ::= VarName COLON TypeSpecifier SEMICOLON {pin=3}

IvarDeclaration ::= IVAR SingleIvarDeclaration+ {pin=1}
SingleIvarDeclaration ::= VarName COLON SimpleTypeSpecifier SEMICOLON {pin=3}

FrozenVarDeclaration ::= FROZENVAR SingleIvarDeclaration {pin=1}
VarName ::= ComplexIdentifier
    | "\"" ComplexIdentifier "\""

FunctionDeclaration ::= FUN_KW FunctionSpecification+
FunctionSpecification ::= FunctionName COLON FunctionTypeSpecifier SEMICOLON {pin=3}
FunctionName ::= ComplexIdentifier
FunctionTypeSpecifier ::= FunctionArgTypesSpecifier IMPLICATION SimpleTypeSpecifier
FunctionArgTypesSpecifier ::= SimpleTypeSpecifier (MULT SimpleTypeSpecifier)*

DefineDeclaration ::= DEFINE_KW DefineBody+
DefineBody ::= ComplexIdentifier ASSIGN Expr SEMICOLON {pin=3}

ConstantsDeclaration ::= CONSTANTS_KW ConstantsBody SEMICOLON
ConstantsBody ::= ComplexIdentifier (COMMA ComplexIdentifier)*

AssignConstraint ::= ASSIGN_KW SingleAssignConstraint+
SingleAssignConstraint ::= AssignExpr SEMICOLON
private AssignExpr ::= InitAssignExpr | NextAssignExpr | SimpleAssignExpr
SimpleAssignExpr ::= ComplexIdentifier ASSIGN Expr
InitAssignExpr ::= INIT_FUN LPAREN ComplexIdentifier RPAREN ASSIGN Expr
NextAssignExpr ::= NEXT LPAREN ComplexIdentifier RPAREN ASSIGN Expr

TransConstraint ::= TRANS_KW Expr SEMICOLON?

InitConstraint ::= INIT_KW Expr SEMICOLON?

InvarConstraint ::= INVAR_KW Expr (IMPLICATION Expr)? SEMICOLON?

FairnessConstraint ::= FAIRNESS_KW Expr SEMICOLON?
JusticeConstraint ::= JUSTICE_KW Expr SEMICOLON?
CompassionConstraint ::= COMPASSION_KW LPAREN Expr COMMA Expr RPAREN SEMICOLON?

IsaDeclaration ::= ISA_KW IDENTIFIER

PredDeclaration ::= PRED_KW Expr SEMICOLON?
    | PRED_KW LESS Expr GREATER ASSIGN Expr SEMICOLON?

ComputeSpecification ::= COMPUTE_KW ComputeExpr SEMICOLON?
    | COMPUTE_KW NAME_KW identifier ASSIGN ComplexIdentifier SEMICOLON?
ComputeExpr ::= (MIN_KW | MAX_KW) LBRACKET RtCtlExpr COMMA RtCtlExpr RBRACKET
RtCtlExpr ::= Expr
    | ("EBF" | "ABF" | "EBG" | "ABG") INTEGER_NUMBER RANGE INTEGER_NUMBER RtCtlExpr
    | ("A" | "E") LBRACKET RtCtlExpr "BU" RtCtlExpr RBRACKET

// parameter_synth_problem
ParameterSynthProblemDeclaration ::= PARSYNTH_KW ParameterSynthProblem SEMICOLON?
ParameterSynthProblem ::= identifier ASSIGN LBRACE IdList OR [VALID_KW | SAT_KW] Expr SynthOpts RBRACE
IdList ::= identifier (COMMA identifier)*
SynthOpts ::= SynthOpt (COMMA SynthOpt)*
SynthOpt ::= MONONEG_KW
    | MONOPOS_KW
    | (MIN_KW | MAX_KW) LPAREN Expr RPAREN

MirrorDeclaration ::= MIRROR_KW VariableIdentifier SEMICOLON?

VariableIdentifier ::= ComplexIdentifier

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////

TypeSpecifier ::= SimpleTypeSpecifier | ModuleTypeSpecifier
SimpleTypeSpecifier ::= BOOLEAN_TYPE
    | WORD_TYPE LBRACKET WholeNumber RBRACKET
    | UNSIGNED_WORD_TYPE LBRACKET WholeNumber RBRACKET
    | SIGNED_WORD_TYPE LBRACKET WholeNumber RBRACKET
    | INTEGER_TYPE
    | REAL_TYPE
    | CLOCK_TYPE
    | LBRACE EnumerationTypeBody RBRACE
    | WholeNumber RANGE WholeNumber
    | ARRAY_TYPE WholeNumber RANGE WholeNumber ARRAY_OF SimpleTypeSpecifier
EnumerationTypeBody ::= EnumerationTypeValue (COMMA EnumerationTypeValue)*
EnumerationTypeValue ::= WholeNumber | ComplexIdentifier
ModuleTypeSpecifier ::= SimpleIdentifier ParameterList
ParameterList ::= LPAREN [Expr (COMMA Expr)*] RPAREN

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

Expr ::= ImplicationBasicExpr
    | EquivalenceBasicExpr
    | TernaryBasicExpr
    | BooleanOrBasicExprGroup
    | AndBasicExpr
    | ComparisonBasicExprGroup
    | InBasicExpr
    | UnionBasicExpr
    | ShiftBasicExprGroup
    | AddBasicExprGroup
    | MulBasicExprGroup
    | ConcatBasicExpr
    | UnaryMinusBasicExpr
    | LogicalNotBasicExpr
    | IndexBasicExpr
    | CaseBasicExpr
    | FunctionCallBasicExpr
    | CtlExprGroup
    | LtlExprGroup
    | PrimaryBasicExprGroup

CaseBasicExpr ::= CASE RegularCaseBody+ ESAC
RegularCaseBody ::= Expr COLON Expr SEMICOLON
TernaryBasicExpr ::= Expr QUESTION_MARK Expr COLON Expr

private ComparisonBasicExprGroup ::= LessBasicExpr | GreaterBasicExpr | LessEqBasicExpr | GreaterEqBasicExpr | EqualityBasicExpr | NotEqualityBasicExpr
LessBasicExpr ::= Expr LESS Expr
GreaterBasicExpr ::= Expr GREATER Expr
LessEqBasicExpr ::= Expr LESS_EQ Expr
GreaterEqBasicExpr ::= Expr GREATER_EQ Expr
EqualityBasicExpr ::= Expr EQUALITY Expr
NotEqualityBasicExpr ::= Expr NOT_EQUALITY Expr

ConcatBasicExpr ::= Expr CONCAT Expr
UnionBasicExpr ::= Expr UNION Expr
InBasicExpr ::= Expr IN Expr

ImplicationBasicExpr ::= Expr IMPLICATION Expr {rightAssociative = true}
EquivalenceBasicExpr ::= Expr EQUIVALENCE Expr
private BooleanOrBasicExprGroup ::= OrBasicExpr | XorBasicExpr | NotXorBasicExpr
OrBasicExpr ::= Expr OR Expr
XorBasicExpr ::= Expr XOR Expr
NotXorBasicExpr ::= Expr NOT_XOR Expr
AndBasicExpr ::= Expr AND Expr

private AddBasicExprGroup ::= PlusBasicExpr | MinusBasicExpr
PlusBasicExpr ::= Expr PLUS Expr
MinusBasicExpr ::= Expr MINUS Expr

private MulBasicExprGroup ::= MulBasicExpr | DivBasicExpr | ModBasicExpr
MulBasicExpr ::= Expr MULT Expr
DivBasicExpr ::= Expr DIV Expr
ModBasicExpr ::= Expr MOD Expr

private ShiftBasicExprGroup ::= ShiftLeftBasicExpr | ShiftRightBasicExpr
ShiftLeftBasicExpr ::= Expr SHIFT_LEFT Expr
ShiftRightBasicExpr ::= Expr SHIFT_RIGHT Expr

LogicalNotBasicExpr ::= NOT Expr
UnaryMinusBasicExpr ::= MINUS Expr

IndexBasicExpr ::= Expr LBRACKET WholeNumber (SEMICOLON WholeNumber)? RBRACKET {pin=2}

FunctionCallBasicExpr ::= FunctionIdentifier LPAREN BasicExprList RPAREN
FunctionIdentifier ::= INIT_FUN | NEXT | SimpleIdentifier
BasicExprList ::= Expr (COMMA Expr)*

///////////////////////////////////////////////////////////////////////////////////////////////////
// CTL SPEC
///////////////////////////////////////////////////////////////////////////////////////////////////
private CtlExprGroup ::= UnaryCtlExpr
    | UntilCtlExpr
UnaryCtlExpr ::= UnaryCtlOp Expr
UnaryCtlOp ::= "EG" | "EX" | "EF" | "AG" | "AX" | "AF"
UntilCtlExpr ::= UntilCtlOp LBRACKET Expr "U" Expr RBRACKET
UntilCtlOp ::= "E" | "A"

///////////////////////////////////////////////////////////////////////////////////////////////////
// LTL SPEC
///////////////////////////////////////////////////////////////////////////////////////////////////
private LtlExprGroup ::= UnaryLtlExpr
    | BinaryLtlExpr
    | TimedLtlExpr
UnaryLtlExpr ::= UnaryLtlOp Expr
UnaryLtlOp ::= "O" | "H" | "Z" | "Y" | "F" | "G" | "X"
BinaryLtlExpr ::= Expr BinaryLtlOp Expr
BinaryLtlOp ::= "@O~" | "@F~" | "T" | "S" | "V" | "U"
TimedLtlExpr ::= TimeLtlOp LPAREN Expr RPAREN
TimeLtlOp ::= "time_since" | "time_until"

private PrimaryBasicExprGroup ::= ReferenceBasicExpr | LiteralBasicExpr | ParenthesisBasicExpr
ParenthesisBasicExpr ::= LPAREN Expr RPAREN
LiteralBasicExpr ::= BooleanConstant
    | WholeNumber
    | RealNumber
    | WordConstant
    | RangeConstant
    | BuiltInConstant
BooleanConstant ::= TRUE | FALSE
WordConstant ::= "0" ("u"|"s")? ["b" | "B"] WholeNumber? "_" HEX_NUMBER
RangeConstant ::= WholeNumber RANGE WholeNumber
WholeNumber ::= POSITIVE_INTEGER_NUMBER | INTEGER_NUMBER
RealNumber ::= FLOAT_NUMBER | FRACTIONAL_NUMBER | EXPONENTIAL_NUMBER
BuiltInConstant ::= TIME | PI
ReferenceBasicExpr ::= ComplexIdentifier | SimpleIdentifier
ComplexIdentifier ::= BaseIdentifier (DOT SimpleIdentifier) * (LBRACKET Expr RBRACKET)?
private BaseIdentifier ::= SimpleIdentifier | SELF
SimpleIdentifier ::= IDENTIFIER
